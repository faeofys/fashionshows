<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Fashion Show - Week 19 – Flipbook</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<style>
  :root{ --bg:#0e0f14; --fg:#f3f6fb; --muted:#99a2b3; --line:#1f2332; --ink:#11182a; }
  *{ box-sizing:border-box }
  html,body{ height:100%; }

  /* Never show scrollbars */
  html, body {
    margin:0;
    background:var(--bg);
    color:var(--fg);
    font:16px/1.45 system-ui,Segoe UI,Inter,Roboto,Arial;
    overflow:hidden;           /* no vertical or horizontal bars */
    scrollbar-width:none;      /* Firefox */
  }
  html::-webkit-scrollbar, body::-webkit-scrollbar { display:none; } /* WebKit */

  .wrap{ min-height:100svh; display:flex; flex-direction:column }
  header{ padding:10px 14px; border-bottom:1px solid var(--line); background:var(--ink); display:flex; align-items:center; gap:10px }
  header h1{ margin:0; font-size:14px; font-weight:700; overflow:hidden; text-overflow:ellipsis; white-space:nowrap; flex:1 }
  .controls{ display:flex; gap:8px; align-items:center; flex-wrap:wrap }
  .controls button{
    appearance:none; border:1px solid var(--line); background:#151a27; color:#fff; border-radius:10px;
    padding:8px 12px; font-weight:600; cursor:pointer
  }

  .stage{
    flex:1; display:grid; place-items:center;
    padding:8px;
    min-height:0;
    overscroll-behavior: contain; /* reduce rubber-banding within stage */
  }

  /* Allow native panning + pinch zoom, but no ghost-click issues */
  #book { touch-action: pan-x pan-y pinch-zoom; }

  .page{
    background:#fff; overflow:hidden; display:flex; align-items:center; justify-content:center; cursor:pointer
  }
  .page img{
    max-width:100%; max-height:100%; width:auto; height:auto; object-fit:contain; display:block;
    image-rendering:auto;
  }
  .hard{ background:#f2f2f2 }

  .hint{ color:var(--muted); text-align:center; margin:8px 0 12px }

  @media (max-width:700px){
    header h1{ max-width:52vw }
  }
</style>
</head>
<body>
<div class="wrap">
  <header>
    <h1>Fashion Show - Week 19 – Flipbook</h1>
    <div class="controls">
      <button id="fitBtn" title="Cycle: Fit Screen → Fit Width → Fit Height → Actual">Fit: Screen</button>
      <button id="prevBtn" aria-label="Previous page">◀ Prev</button>
      <button id="nextBtn" aria-label="Next page">Next ▶</button>
    </div>
  </header>

  <div class="stage">
    <div id="book" class="magazine"></div>
  </div>

  <p class="hint">Click/tap left = previous, right = next. Keys: ← →. Double-tap toggles fit mode. Pinch to zoom.</p>
</div>

<script>
  const PAGES = [
  "images/page-001.jpg",
  "images/page-002.jpg",
  "images/page-003.jpg",
  "images/page-004.jpg",
  "images/page-005.jpg",
  "images/page-006.jpg",
  "images/page-007.jpg",
  "images/page-008.jpg",
  "images/page-009.jpg",
  "images/page-010.jpg",
  "images/page-011.jpg",
  "images/page-012.jpg",
  "images/page-013.jpg",
  "images/page-014.jpg",
  "images/page-015.jpg",
  "images/page-016.jpg",
  "images/page-017.jpg",
  "images/page-018.jpg",
  "images/page-019.jpg",
  "images/page-020.jpg",
  "images/page-021.jpg",
  "images/page-022.jpg",
  "images/page-023.jpg",
  "images/page-024.jpg",
  "images/page-025.jpg",
  "images/page-026.jpg",
  "images/page-027.jpg",
  "images/page-028.jpg",
  "images/page-029.jpg",
  "images/page-030.jpg",
  "images/page-031.jpg",
  "images/page-032.jpg",
  "images/page-033.jpg",
  "images/page-034.jpg",
  "images/page-035.jpg",
  "images/page-036.jpg",
  "images/page-037.jpg",
  "images/page-038.jpg",
  "images/page-039.jpg",
  "images/page-040.jpg",
  "images/page-041.jpg",
  "images/page-042.jpg",
  "images/page-043.jpg",
  "images/page-044.jpg",
  "images/page-045.jpg",
  "images/page-046.jpg",
  "images/page-047.jpg",
  "images/page-048.jpg",
  "images/page-049.jpg",
  "images/page-050.jpg"
];
  function addPages(el){
    const make = (src, extra='') => '<div class="page '+extra+'"><img loading="lazy" decoding="async" src="'+src+'" alt="" /></div>';
    if (PAGES.length){
      el.insertAdjacentHTML('beforeend', make(PAGES[0],'hard'));
      for (let i=1;i<PAGES.length-1;i++){ el.insertAdjacentHTML('beforeend', make(PAGES[i])); }
      if (PAGES.length>1) el.insertAdjacentHTML('beforeend', make(PAGES[PAGES.length-1],'hard'));
    }
  }
</script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.7.1/jquery.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/turn.js/3/turn.min.js"></script>
<script>
(function(){
  const bookEl   = document.getElementById('book');
  const stageEl  = document.querySelector('.stage');
  const headerEl = document.querySelector('header');
  const hintEl   = document.querySelector('.hint');
  const fitBtn   = document.getElementById('fitBtn');

  // Modes: 'screen' (default), 'width', 'height', 'actual'
  const FIT_SEQUENCE = ['screen','width','height','actual'];
  let fitModeIndex = 0;

  // --- IMPORTANT: declare before Turn.js init ---
  let isTurning = false;

  addPages(bookEl);

  $('#book').turn({
    autoCenter:true,
    elevation:50,
    gradients:true,
    display:'double',
    when:{
      turning: function(e, page){ isTurning = true; },
      turned:  function(e, page){ isTurning = false; }
    }
  });

  // Ensure integer pixel sizes to avoid blur/jitter
  function i(v){ return Math.max(1, Math.floor(v)); }

  function availableSize(){
    const vw = window.innerWidth;
    const vh = window.innerHeight;

    const headerH = headerEl.getBoundingClientRect().height || 0;
    const hintH   = hintEl.getBoundingClientRect().height || 0;

    const stagePadV = 16;
    const stagePadH = 16;

    const maxW = i(vw - stagePadH);
    const maxH = i(vh - headerH - hintH - stagePadV);

    return { maxW: Math.max(240, maxW), maxH: Math.max(180, maxH) };
  }

  function setFitButtonLabel(mode){
    const labels = {
      screen: 'Fit: Screen',
      width:  'Fit: Width',
      height: 'Fit: Height',
      actual: 'Actual Size'
    };
    fitBtn.textContent = labels[mode] || 'Fit: Screen';
    fitBtn.title = 'Cycle: Fit Screen → Fit Width → Fit Height → Actual';
  }

  function currentDisplay(){
    const { maxW } = availableSize();
    return (maxW < 700) ? 'single' : 'double';
  }

  function sizeBook(){
    const mode = FIT_SEQUENCE[fitModeIndex];
    setFitButtonLabel(mode);

    const disp = currentDisplay();
    if ($('#book').turn('display') !== disp){
      $('#book').turn('display', disp);
    }

    const natW = (disp === 'single') ? 1224 : 2448;
    const natH = (disp === 'single') ? 1584 : 1584;

    const { maxW, maxH } = availableSize();

    let targetW = natW, targetH = natH;

    if (mode === 'screen'){
      const s = Math.min(maxW / natW, maxH / natH, 1);
      targetW = i(natW * s);
      targetH = i(natH * s);
    }
    else if (mode === 'width'){
      const s = Math.min(maxW / natW, 1);
      targetW = i(natW * s);
      targetH = i(natH * s);
      if (targetH > maxH){
        const s2 = maxH / natH;
        targetW = i(natW * s2);
        targetH = i(natH * s2);
      }
    }
    else if (mode === 'height'){
      const s = Math.min(maxH / natH, 1);
      targetW = i(natW * s);
      targetH = i(natH * s);
      if (targetW > maxW){
        const s2 = maxW / natW;
        targetW = i(natW * s2);
        targetH = i(natH * s2);
      }
    }
    else if (mode === 'actual'){
      targetW = Math.min(natW, maxW);
      targetH = Math.min(natH, maxH);
    }

    $('#book').turn('size', targetW, targetH);
  }

  // Initial and reactive sizing
  sizeBook();
  const ro = new ResizeObserver(sizeBook);
  ro.observe(stageEl);
  window.addEventListener('resize', sizeBook);

  // Cycle fit modes
  fitBtn.addEventListener('click', () => {
    fitModeIndex = (fitModeIndex + 1) % FIT_SEQUENCE.length;
    sizeBook();
  });

  // ===== Pointer Events tap handling (single source of truth) =====
  // Double-tap toggles fit (no flip). Multi-touch (pinch) should not flip pages.
  let lastTap = 0;
  let suppressNextFlip = false;

  // Track active pointers to detect multi-touch gestures
  const activePointers = new Set();
  let hadMultiTouchRecently = false;
  let multiTouchTimer = null;

  function markMultiTouch() {
    hadMultiTouchRecently = true;
    clearTimeout(multiTouchTimer);
    multiTouchTimer = setTimeout(() => { hadMultiTouchRecently = false; }, 250);
  }

  bookEl.addEventListener('pointerdown', (e) => {
    activePointers.add(e.pointerId);
    if (activePointers.size > 1) {
      markMultiTouch(); // a pinch/rotate started
    }
  }, { passive: true });

  bookEl.addEventListener('pointercancel', (e) => {
    activePointers.delete(e.pointerId);
  }, { passive: true });

  bookEl.addEventListener('pointerup', (e) => {
    activePointers.delete(e.pointerId);
    if (!e.isPrimary) return;

    // If a multi-touch gesture just occurred, or a turn is animating, don't flip
    if (hadMultiTouchRecently || isTurning) return;

    // Double-tap on touch toggles fit and does NOT flip
    if (e.pointerType === 'touch') {
      const now = Date.now();
      if (now - lastTap < 300) {
        suppressNextFlip = true;
        fitBtn.click(); // toggle fit mode
        setTimeout(() => suppressNextFlip = false, 0);
        lastTap = 0;
        return;
      }
      lastTap = now;
    }

    if (suppressNextFlip) return;

    const rect = bookEl.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const isSingle = ($('#book').turn('display') === 'single');

    if (isSingle){
      (x > rect.width * 0.4) ? $('#book').turn('next') : $('#book').turn('previous');
    } else {
      (x < rect.width/2) ? $('#book').turn('previous') : $('#book').turn('next');
    }
  }, { passive: true });

  // Buttons + keyboard
  document.getElementById('prevBtn').addEventListener('click',()=>$('#book').turn('previous'));
  document.getElementById('nextBtn').addEventListener('click',()=>$('#book').turn('next'));
  document.addEventListener('keydown', (e)=>{
    if (e.key === 'ArrowLeft')  $('#book').turn('previous');
    if (e.key === 'ArrowRight') $('#book').turn('next');
  });
})();
</script>
</body>
</html>